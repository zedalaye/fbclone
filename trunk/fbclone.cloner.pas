unit fbclone.cloner;

interface

{$IFDEF ENABLE_BENCHMARK}
  {$DEFINE BENCH}
{$ENDIF}

uses
  Windows, SysUtils, Classes,
  uib, uiblib, uibase, uibmetadata, uibconst,
  fbclone.database,
{$IFDEF BENCH}
   fbclone.benchmark,
{$ENDIF}
   fbclone.logger;

{$I uib.inc}

type
  TClonerOption = (coVerbose, coPumpOnly, coEmptyTables, coFailSafe);
  TClonerOptions = set of TClonerOption;

  TCloner = class
  private
    FPageSize: Integer;
    FTargetCharset: String;
    FReadCharset: String;
    FWriteCharset: String;
    FOptions: TClonerOptions;
    FCommitInterval: Integer;
    FDumpFile: String;
    FRepairFile: String;
    FLogger: ILogger;
    FExcludedTables: TStringList;
    procedure AddLog(const What: String = ''; Level: TLogLevel = llInfo); overload;
    procedure AddLog(const FmtStr: String; const Args: array of const; Level: TLogLevel = llInfo); overload;
    procedure DumpIntoRepairLog(const error, sql: string);
    function PumpData(dbhandle: IscDbHandle; mdb: TMetaDataBase; charset: TCharacterSet;
      SrcQuery: TUIBQuery; DstDatabase: TUIBDatabase; DstTransaction: TUIBTransaction): Integer;
  public
    constructor Create;
    destructor Destroy; override;
    function Clone(const Source, Target: TDatabase): Boolean;
    procedure AddExcludedTable(const TableName: string);
    property Options: TClonerOptions read FOptions write FOptions;
    property PageSize: Integer read FPageSize write FPageSize;
    property TargetCharset: String read FTargetCharset write FTargetCharset;
    property ReadCharset: String read FReadCharset write FReadCharset;
    property WriteCharset: String read FWriteCharset write FWriteCharset;
    property CommitInterval: Integer read FCommitInterval write FCommitInterval;
    property DumpFile: String read FDumpFile write FDumpFile;
    property RepairFile: String read FRepairFile write FRepairFile;
    property Logger: ILogger read FLogger write FLogger;
  end;

implementation

{ TCloner }

constructor TCloner.Create;
begin
  FPageSize := 0;
  FTargetCharset := 'UTF8';
  FReadCharset := 'NONE';
  FWriteCharset := 'WIN1252';
  FOptions := [];
  FCommitInterval := 10000;
  FDumpFile := '';
  FRepairFile := '';
  FLogger := nil;
  FExcludedTables := TStringList.Create;
  FExcludedTables.Sorted := true;
  FExcludedTables.Duplicates := dupIgnore;
end;

destructor TCloner.Destroy;
begin
  FExcludedTables.Free;
  inherited;
end;

procedure TCloner.DumpIntoRepairLog(const error, sql: string);
var
  F: TFileStream;
  BOM: TBytes;
  M: Word;

  procedure WriteString(const Str: string);
  var
    S: TStringStream;
  begin
    S := TStringStream.Create(Str, TEncoding.UTF8);
    try
      F.CopyFrom(S, 0);
    finally
      S.Free;
    end;
  end;

begin
  if RepairFile = '' then
    Exit;

  if FileExists(RepairFile) then
    M := fmOpenReadWrite
  else
    M := fmCreate;

  F := TFileStream.Create(RepairFile, M + fmShareDenyWrite);
  try
    F.Seek(0, soFromEnd);
    if M = fmCreate then
    begin
      BOM := TEncoding.UTF8.GetPreamble;
      F.Write(BOM[0], Length(BOM));

      WriteString('/*'
      + NewLine + '          Repair Script - Generated by FBClone'
      + NewLine
      + NewLine + '  Usage : Fix manually problems that caused errors below then'
      + NewLine + '          run this script (eg: with isql -i) to restore '
      + NewLine + '          missing metadata into your database'
      + NewLine + '*/');
    end;
    WriteString(NewLine + NewLine + '/*' + error + '*/' + NewLine + NewLine + sql);
 finally
    F.Free;
  end;
end;

function TCloner.PumpData(dbhandle: IscDbHandle; mdb: TMetaDataBase; charset: TCharacterSet;
  SrcQuery: TUIBQuery; DstDatabase: TUIBDatabase; DstTransaction: TUIBTransaction): Integer;
var
  T,F,c,l: Integer;
  done: Integer;
  sql, info: string;
  trhandle: IscTrHandle;
  sthandle: IscStmtHandle;
  blhandle: IscBlobHandle;
  Table: TMetaTable;
{$IFDEF BENCH}
  S: TPerformanceStats;
{$ELSE}
  S, E: Cardinal;
{$ENDIF}
  LastDisplay: Cardinal;
  first_blob: Integer;

  procedure LogError(E: EUIBError; Q: TUIBQuery);
  var
    c: Integer;
  begin
    AddLog('------ failure ------', llError);
    AddLog('ErrorCode = %d' + #13#10 + 'SQLCode = %d', [E.ErrorCode, E.SQLCode], llError);
    AddLog(e.Message, llError);
    AddLog('--- fields values ---', llError);
    for c := 0 to Q.Fields.FieldCount - 1 do
      case Q.Fields.FieldType[c] of
        uftBlob, uftBlobId:
          AddLog('%s = [BLOB]', [Q.Fields.AliasName[c]], llError);
        uftArray:
          AddLog('%s = [ARRAY]', [Q.Fields.AliasName[c]], llError)
        else
          AddLog('%s = %s', [Q.Fields.AliasName[c], Q.Fields.AsString[c]], llError);
      end;
    AddLog('-- rollback record --', llError);
  end;

  procedure CheckDstTransaction;
  begin
    if not DstTransaction.InTransaction then
    begin
    {$IFDEF BENCH}
      S.transaction_setup.Start;
    {$ENDIF}
        DstTransaction.StartTransaction;
        trhandle := DstTransaction.TrHandle;
    {$IFDEF BENCH}
      S.transaction_setup.Stop;
    {$ENDIF}
    end;
  end;

begin
  Result := 0;

  for T := 0 to mdb.TablesCount - 1 do
  try
  {$IFDEF BENCH}
    S.Reset;
  {$ENDIF}

    Table := mdb.Tables[T];
    AddLog(NewLine + 'Table %s', [Table.Name]);

    if FExcludedTables.IndexOf(Table.Name) >= 0 then
    begin
      AddLog('  EXCLUDED');
      Continue;
    end;

    first_blob := 0;
    sql := 'select ';
    c := 0;
    for F := 0 to Table.FieldsCount - 1 do
      if Table.Fields[F].ComputedSource = '' then
      begin
        if Table.Fields[F].FieldType in [uftBlob, uftBlobId] then
          first_blob := F;

        if (c = 0) then
          sql := sql + Table.Fields[F].Name
        else
          sql := sql + ', ' + Table.Fields[F].Name;
        inc(c);
      end;
    sql := sql + ' from ' + Table.Name;

    if (coPumpOnly in FOptions) and (Table.PrimaryCount > 0) then
    begin
      c := 0;
      for F := 0 to Table.Primary[0].FieldsCount - 1 do
      begin
        if (c = 0) then
          sql := sql + ' order by '
        else
          sql := sql + ', ';
        sql := sql + Table.Primary[0].Fields[F].Name;
        Inc(c);
      end;
    end;

    done := 0;
    LastDisplay := 0;

  {$IFDEF BENCH}
    S.reading_prepare.Start;
  {$ENDIF}
      SrcQuery.SQL.Text := sql;
      SrcQuery.Prepare(true);
  {$IFDEF BENCH}
    S.reading_prepare.Stop;
  {$ENDIF}

  {$IFDEF BENCH}
    S.reading.Start;
  {$ENDIF}
      SrcQuery.Open;
  {$IFDEF BENCH}
    S.reading.Stop;
  {$ENDIF}

  {$IFNDEF BENCH}
    S := GetTickCount;
  {$ENDIF}

    if not (SrcQuery.Eof) then
    begin
      with DstDatabase.Lib do
      begin
        CheckDstTransaction;

        if [coPumpOnly, coEmptyTables] >= FOptions then
        begin
          sql := format('delete from %s', [Table.Name]);

        {$IFDEF BENCH}
          S.deleting.Start;
        {$ENDIF}
            DSQLExecuteImmediate(dbhandle, trhandle, MBUEncode(sql, CharacterSetCP[charset]), 3, nil);
        {$IFDEF BENCH}
          S.deleting.Stop;
        {$ENDIF}
        end;

        sql := format('insert into %s (%s', [Table.Name, Table.MetaQuote(SrcQuery.Fields.SqlName[0])]);
        for F := 1 to SrcQuery.Fields.FieldCount - 1 do
          sql := sql + ', ' + Table.MetaQuote(SrcQuery.Fields.SqlName[F]);
        sql := sql + ') values (?';
        for F := 1 to SrcQuery.Fields.FieldCount - 1 do
          sql := sql + ',?';
        sql := sql + ');';

      {$IFDEF BENCH}
        S.prepare.Start;
      {$ENDIF}
          sthandle := nil;
          DSQLAllocateStatement(dbhandle, sthandle);
          DSQLPrepare(dbhandle, trhandle, sthandle,  MBUEncode(sql, CharacterSetCP[charset]), 3, nil);
      {$IFDEF BENCH}
        S.prepare.Stop;
      {$ENDIF}

        while not SrcQuery.Eof do
        begin
          // recreate blobs
          if first_blob > 0 then
            for F := first_blob to SrcQuery.Fields.FieldCount - 1 do
              case SrcQuery.Fields.FieldType[F] of
                uftBlob, uftBlobId:
                  begin
                    if (not SrcQuery.Fields.IsNull[F]) then
                    begin
                      CheckDstTransaction;
                    {$IFDEF BENCH}
                      S.blobs.Start;
                    {$ENDIF}
                        blhandle := nil;
                        TSQLDA(SrcQuery.Fields).AsQuad[F] := BlobCreate(dbhandle, trhandle, blhandle);
                        BlobWriteSegment(blhandle, SrcQuery.Fields.BlobData[F].Size, SrcQuery.Fields.BlobData[F].Buffer);
                        BlobClose(blhandle);
                      {$IFDEF BENCH}
                      S.blobs.Stop;
                    {$ENDIF}
                    end;
                  end
              end;

          // recreate array
          for F := 0 to SrcQuery.Fields.ArrayCount - 1 do
            if (not SrcQuery.Fields.IsNull[SrcQuery.Fields.ArrayInfos[F].index]) then
            begin
              CheckDstTransaction;
            {$IFDEF BENCH}
              S.arrays.Start;
            {$ENDIF}
                l := SrcQuery.Fields.ArrayInfos[F].index;
                TSQLDA(SrcQuery.Fields).AsQuad[l] := QuadNull;
                TSQLDA(SrcQuery.Fields).IsNull[l] := false;
                ArrayPutSlice(dbhandle, trhandle, PGDSQuad(SrcQuery.Fields.Data.sqlvar[l].SqlData)^, SrcQuery.Fields.ArrayInfos[F].info, SrcQuery.Fields.ArrayData[l], SrcQuery.Fields.ArrayInfos[F].size);
            {$IFDEF BENCH}
              S.arrays.Stop;
            {$ENDIF}
            end;

          try
            CheckDstTransaction;
          {$IFDEF BENCH}
            S.writing.Start;
          {$ENDIF}
              DSQLExecute(trhandle, sthandle, 3, SrcQuery.Fields);
          {$IFDEF BENCH}
            S.writing.Stop;
          {$ENDIF}

            Inc(done);

            if (coFailSafe in FOptions) or (done mod FCommitInterval = 0) then
            begin
            {$IFDEF BENCH}
              S.transaction_commit.Start;
            {$ENDIF}
                DstTransaction.Commit;
            {$IFDEF BENCH}
              S.transaction_commit.Stop;
            {$ENDIF}
            end;

            if (coVerbose in FOptions) and (GetTickCount - LastDisplay > 100) then
            begin
            {$IFDEF BENCH}
              info := Format('  %d records - %.1f rps', [done, done / S.TotalWritingTime]);
            {$ELSE}
              E := GetTickCount - S;
              if E = 0 then
                info := Format('  %d records - -- rps', [done])
              else
                info := Format('  %d records - %.1f rps', [done, done * 1000 / E]);
            {$ENDIF}
              Write(info, StringOfChar(' ', 80 - (Length(info) + 1)), #13);
              LastDisplay := GetTickCount;
            end;
          except
            on E: EUIBError do
            begin
              LogError(E, SrcQuery);
            {$IFDEF BENCH}
              S.transaction_commit.Start;
            {$ENDIF}
                DstTransaction.Commit;
            {$IFDEF BENCH}
              S.transaction_commit.Stop;
            {$ENDIF}
              Inc(Result);
            end;
          end;

        {$IFDEF BENCH}
          S.reading.Start;
        {$ENDIF}
            SrcQuery.Next;
        {$IFDEF BENCH}
          S.reading.Stop;
        {$ENDIF}
        end;

        if DstTransaction.InTransaction then
        begin
          try
          {$IFDEF BENCH}
            S.transaction_commit.Start;
          {$ENDIF}
              DstTransaction.Commit;
          {$IFDEF BENCH}
            S.transaction_commit.Stop;
          {$ENDIF}
          except
            on E: EUIBError do
            begin
              LogError(E, SrcQuery);
              Inc(Result);
            end;
          end;
        end;

      {$IFDEF BENCH}
        S.drop.Start;
      {$ENDIF}
          DSQLFreeStatement(sthandle, DSQL_drop);
      {$IFDEF BENCH}
        S.drop.Stop;
      {$ENDIF}
      end;
    end;

  {$IFDEF BENCH}
    S.reading_commit.Start;
  {$ENDIF}
      SrcQuery.Close(etmCommit);
  {$IFDEF BENCH}
    S.reading_commit.Stop;
  {$ENDIF}

  {$IFDEF BENCH}
    if S.TotalWritingTime = 0 then
      info := '  0 record'
    else
      info := Format('  %d records - %.1f rps', [done, done / S.TotalWritingTime]);
    AddLog(info + StringOfChar(' ', 80 - (Length(info) + 2)));
    AddLog(#13#10 +
           '  Stats' + #13#10 +
           S.LastToString(4) + #13#10);
  {$ELSE}
    E := GetTickCount - S;
    if (E = 0) then
      info := Format('  %d records', [done])
    else
      info := Format('  %d records - %.1f rps', [done, done * 1000 / E]);
    AddLog(info + StringOfChar(' ', 80 - (Length(info) + 2)));
  {$ENDIF}
  except
    on E: Exception do
    begin
      AddLog('------ failure ------', llError);
      AddLog(e.Message, llError);
      AddLog('---------------------', llError);
      Inc(Result);
      Continue;
    end;
  end;

{$IFDEF BENCH}
  AddLog(#13#10 + 'Global Stats');
  AddLog(S.GlobalToString);
{$ENDIF}
end;

procedure TCloner.AddLog(const What: String; Level: TLogLevel);
begin
  if (FLogger <> nil) and (coVerbose in FOptions) then
    FLogger.Trace(What, Level);
end;

procedure TCloner.AddExcludedTable(const TableName: string);
begin
  FExcludedTables.Add(TableName);
end;

procedure TCloner.AddLog(const FmtStr: String; const Args: array of const;
  Level: TLogLevel);
begin
  AddLog(Format(FmtStr, Args), Level);
end;

function TCloner.Clone(const Source, Target: TDatabase): Boolean;
var
  SrcDatabase, DstDatabase: TUIBDatabase;
  SrcTransaction, DstTransaction: TUIBTransaction;
  SrcQuery: TUIBQuery;
  FErrorsCount: Integer;
  SQLDump: TStringStream;
{$IFDEF BENCH}
  Perfs: TOverallPerformanceStats;
{$ENDIF}
var
  i, j: integer;
  dbhandle: IscDbHandle;
  metasrc, metatgt: TMetaDataBase;
  source_charset, target_charset,
  read_charset, write_charset: TCharacterSet;

  function GetDefaultCharset(const Tr: TUIBTransaction): TCharacterSet;
  var
    m: TMetaDatabase;
  begin
    m := TMetaDatabase.Create(nil, -1);
    try
      m.OIDDatabases := [OIDDBCharset];
      m.LoadFromDatabase(Tr);
      Result := m.DefaultCharset;
    finally
      m.Free;
    end;
  end;

  procedure ChangeCharset(const Db: TUIBDatabase; charset: TCharacterSet);
  begin
    if Db.CharacterSet <> charset then
    begin
    {$IFDEF BENCH}
      if Db = SrcDatabase then
        Perfs.source_disconnection.Start
      else
        Perfs.target_disconnection.Start;
    {$ENDIF}
      Db.Connected := false;
    {$IFDEF BENCH}
      if Db = SrcDatabase then
        Perfs.source_disconnection.Stop
      else
        Perfs.target_disconnection.Stop;
    {$ENDIF}
      Db.CharacterSet := charset;
    {$IFDEF BENCH}
      if Db = SrcDatabase then
        Perfs.source_connection.Start
      else
        Perfs.target_connection.Start;
    {$ENDIF}
      Db.Connected := true;
    {$IFDEF BENCH}
      if Db = SrcDatabase then
        Perfs.source_connection.Stop
      else
        Perfs.target_connection.Stop;
    {$ENDIF}
    end;
  end;

  procedure LoadMetadatas(const Db: TUIBDatabase; const Tr: TUIBTransaction; charset: TCharacterSet; var meta: TMetaDataBase);
  begin
    ChangeCharset(Db, charset);
    { Lit l'intégralité des métadonnées }
    meta.OIDDatabases := ALLObjects;
    meta.LoadFromDatabase(Tr);
  end;

  procedure ExecuteImmediate(const SQL: string);
  begin
    try
      DstTransaction.ExecuteImmediate(sql);
      DstTransaction.Commit;
    except
      on e: Exception do
      begin
        AddLog('------ failure ------', llError);
        AddLog(sql, llError);
        AddLog('----- exception -----', llError);
        AddLog(e.Message, llError);
        AddLog('---------------------', llError);
        DumpIntoRepairLog(e.Message, sql);
        inc(FErrorsCount);
      end;
    end;
  end;

  function ConvertCharset(const Charset: string; DefaultValue: TCharacterSet): TCharacterSet;
  begin
    if Charset <> '' then
      Result := StrToCharacterSet(RawByteString(Charset))
    else
      Result := DefaultValue;
  end;

begin
{$IFDEF BENCH}
  Perfs.duration.Start;
{$ENDIF}

  Result := true;

  FErrorsCount := 0;

  SrcDatabase := TUIBDataBase.Create(nil);
  Source.Configure(SrcDatabase);
  SrcDatabase.Params.Add('no_garbage_collect');

  try
  {$IFDEF BENCH}
    Perfs.source_connection.Start;
  {$ENDIF}
      SrcDatabase.Connected := true;
  {$IFDEF BENCH}
    Perfs.source_connection.Stop;
  {$ENDIF}

    AddLog('Source connection'
           + #13#10 + '  Database  %s'
           + #13#10 + '  Username  %s'
           + #13#10 + '  Page Size %d'
           + #13#10 + '  Client    %s'
{$IFDEF FB102_UP}
           + #13#10 + '  Server    %s'
{$ENDIF},
      [
        Source.ConnectionString,
        Source.Username,
        SrcDatabase.InfoPageSize,
        SrcDatabase.InfoVersion
{$IFDEF FB102_UP}
       ,SrcDatabase.InfoFirebirdVersion
{$ENDIF}
      ]
    );
  except
    on E: EUIBError do
    begin
      AddLog('Cannot connect source database %s' + #13#10 +
             '%s', [Source.ConnectionString, E.Message], llError);
      Exit;
    end;
  end;

  DstDatabase := TUIBDataBase.Create(nil);
  Target.Configure(DstDatabase);
  DstDatabase.Params.Add('num_buffers=50');

  try
  {$IFDEF BENCH}
    Perfs.target_connection.Start;
  {$ENDIF}
      DstDatabase.Connected := true;
  {$IFDEF BENCH}
    Perfs.target_connection.Stop;
  {$ENDIF}

    if coPumpOnly in FOptions then
    begin
      AddLog(#13#10 + 'Target connection'
           + #13#10 + '  Database  %s'
           + #13#10 + '  Username  %s'
           + #13#10 + '  Page Size %d'
           + #13#10 + '  Client    %s'
{$IFDEF FB102_UP}
           + #13#10 + '  Server    %s'
{$ENDIF},
        [
          Target.ConnectionString,
          Target.Username,
          DstDatabase.InfoPageSize,
          DstDatabase.InfoVersion
{$IFDEF FB102_UP}
         ,DstDatabase.InfoFirebirdVersion
{$ENDIF}
        ]
      );
    end
    else
    begin
      try
      {$IFDEF BENCH}
        Perfs.target_drop.Start;
      {$ENDIF}
          DstDatabase.DropDatabase;
      {$IFDEF BENCH}
        Perfs.target_drop.Stop;
      {$ENDIF}
      except
        on E: EUIBError do
        begin
          WriteLn('Impossible de supprimer la base de données cible ' + Target.ConnectionString + #13#10 +
                  E.Message);
          Exit;
        end;
      end;
    end;
  except
    { si on ne peut pas se connecter c'est que la base n'existe pas ! tout baigne }
  {$IFDEF BENCH}
    Perfs.target_connection.Stop;
  {$ENDIF}
  end;

  metasrc := TMetaDataBase.Create(nil,-1);
  metatgt := TMetaDataBase.Create(nil,-1);

  SrcTransaction := TUIBTransaction.Create(nil);
  SrcQuery := TUIBQuery.Create(nil);
  SrcQuery.CachedFetch := false;

  DstTransaction := TUIBTransaction.Create(nil);
  try
    SrcTransaction.Options := [tpRead, tpConcurrency];
    SrcTransaction.DataBase := SrcDatabase;
    SrcQuery.Transaction := SrcTransaction;
    SrcQuery.FetchBlobs := true;

    DstTransaction.Options := [tpWrite, tpReadCommitted, tpNoAutoUndo];
    DstTransaction.DataBase := DstDatabase;

    source_charset := GetDefaultCharset(SrcTransaction);
    if (coPumpOnly in FOptions) and (FTargetCharset = '') then
      target_charset := GetDefaultCharset(DstTransaction)
    else
      target_charset := ConvertCharset(FTargetCharset, source_charset);
    read_charset := ConvertCharset(FReadCharset, source_charset);
    write_charset := ConvertCharset(FWriteCharset, source_charset);

    AddLog(#13#10 + 'Charset summary'
         + #13#10 + '  Source %s'
         + #13#10 + '  Target %s'
         + #13#10 + '  Read   %s'
         + #13#10 + '  Write  %s',
      [
        CharacterSetStr[source_charset],
        CharacterSetStr[target_charset],
        CharacterSetStr[read_charset],
        CharacterSetStr[write_charset]
      ]
    );

  {$IFDEF BENCH}
    Perfs.source_metadata.Start;
  {$ENDIF}
      LoadMetadatas(SrcDatabase, SrcTransaction, read_charset, metasrc);
  {$IFDEF BENCH}
    Perfs.source_metadata.Stop;
  {$ENDIF}

    { Ecrit le script SQL de création de la base de données dans le fichier }
    if DumpFile <> '' then
    begin
      SQLDump := TStringStream.Create;
      try
        metasrc.SaveToDDL(SQLDump, [ddlFull]);
        SQLDump.SaveToFile(DumpFile);
      finally
        SQLDump.Free;
      end;
    end;

    if not (coPumpOnly in FOptions) then
    begin
      if PageSize = 0 then
        PageSize := SrcDatabase.InfoPageSize;

      { Not so important }
      DstDatabase.CharacterSet := target_charset;

    {$IFDEF BENCH}
      Perfs.target_creation.Start;
    {$ENDIF}
        DstDatabase.CreateDatabase(target_charset, PageSize);
    {$IFDEF BENCH}
      Perfs.target_creation.Stop;
    {$ENDIF}

      AddLog(#13#10 + 'Create Target'
           + #13#10 + '  Database  %s'
           + #13#10 + '  Username  %s'
           + #13#10 + '  Page Size %d'
           + #13#10 + '  Client    %s'
{$IFDEF FB102_UP}
           + #13#10 + '  Server    %s'
{$ENDIF},
        [
          Target.ConnectionString,
          Target.Username,
          DstDatabase.InfoPageSize,
          DstDatabase.InfoVersion
{$IFDEF FB102_UP}
         ,DstDatabase.InfoFirebirdVersion
{$ENDIF}
        ]
      );

      ChangeCharset(DstDatabase, write_charset);

      // ROLES
      AddLog(#13#10 + 'Create Roles');
      for i := 0 to metasrc.RolesCount - 1 do
      begin
        AddLog('  %s', [metasrc.Roles[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_roles.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Roles[i].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_roles.Stop;
      {$ENDIF}
      end;

      // UDF
      AddLog(#13#10 + 'Create UDF');
      for i := 0 to metasrc.UDFSCount - 1 do
      begin
        AddLog('  %s', [metasrc.UDFS[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_functions.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.UDFS[i].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_functions.Stop;
      {$ENDIF}
      end;

      // DOMAINS
      AddLog(#13#10 + 'Create Domains');
      for i := 0 to metasrc.DomainsCount - 1 do
      begin
        AddLog('  %s', [metasrc.Domains[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_domains.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Domains[i].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_domains.Stop;
      {$ENDIF}
      end;

      // GENERATORS
      AddLog(#13#10 + 'Create Generators');
      for i := 0 to metasrc.GeneratorsCount - 1 do
      begin
        AddLog('  %s', [metasrc.Generators[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_generators.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Generators[i].AsCreateDLL);
      {$IFDEF BENCH}
        Perfs.meta_generators.Stop;
      {$ENDIF}
      end;

      // EXEPTIONS
      AddLog(#13#10 + 'Create Exceptions');
      for i := 0 to metasrc.ExceptionsCount - 1 do
      begin
        AddLog('  %s', [metasrc.Exceptions[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_exceptions.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Exceptions[i].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_exceptions.Stop;
      {$ENDIF}
      end;

      // EMPTY PROCEDURES
      AddLog(#13#10 + 'Create Empty Procedures');
      for i := 0 to metasrc.ProceduresCount - 1 do
      begin
        AddLog('  %s', [metasrc.Procedures[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_procedures.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Procedures[i].AsCreateEmptyDDL);
      {$IFDEF BENCH}
        Perfs.meta_procedures.Stop;
      {$ENDIF}
      end;

      // TABLES
      AddLog(#13#10 + 'Create Tables');
      for i := 0 to metasrc.TablesCount - 1 do
      begin
        AddLog('  %s', [metasrc.Tables[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_tables.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Tables[i].AsFullDDLNode);
      {$IFDEF BENCH}
        Perfs.meta_tables.Stop;
      {$ENDIF}
      end;

      // VIEWS
      AddLog(#13#10 + 'Create Views');
      for i := 0 to metasrc.SortedViewsCount - 1 do
      begin
        AddLog('  %s', [metasrc.SortedViews[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_views.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.SortedViews[i].AsFullDDLNode);
      {$IFDEF BENCH}
        Perfs.meta_views.Stop;
      {$ENDIF}
      end;
    end;

    if (coPumpOnly in FOptions) then
    begin
    {$IFDEF BENCH}
      Perfs.target_metadata.Start;
    {$ENDIF}
        LoadMetadatas(DstDatabase, DstTransaction, target_charset, metatgt);
    {$IFDEF BENCH}
      Perfs.target_metadata.Stop;
    {$ENDIF}

      AddLog(#13#10 + 'Deactivating Constraints');
      for i := 0 to metatgt.TablesCount - 1 do
      begin
        AddLog(#13#10 + 'Table %s', [metatgt.Tables[i].Name]);
        // DEACTIVATE TRIGGERS
        AddLog('  Triggers');
        for j := 0 to metatgt.Tables[i].TriggersCount - 1 do
        begin
          AddLog('  %s', [metatgt.Tables[i].Triggers[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_triggers.Start;
        {$ENDIF}
            ExecuteImmediate(metatgt.Tables[i].Triggers[j].AsAlterToInactiveDDL);
        {$IFDEF BENCH}
          Perfs.meta_triggers.Stop;
        {$ENDIF}
        end;
        // DEACTIVATE FOREIGN KEYS
        AddLog('  Foreign Keys');
        for j := 0 to metatgt.Tables[i].ForeignCount - 1 do
        begin
          AddLog('    %s', [metatgt.Tables[i].Foreign[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_foreign.Start;
        {$ENDIF}
            ExecuteImmediate(metatgt.Tables[i].Foreign[j].AsDropDDL);
        {$IFDEF BENCH}
          Perfs.meta_foreign.Stop;
        {$ENDIF}
        end;
        // DEACTIVATE UNIQUES
        AddLog('  Unique Indices');
        for j := 0 to metatgt.Tables[i].UniquesCount - 1 do
        begin
          AddLog('    %s', [metatgt.Tables[i].Uniques[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_unique.Start;
        {$ENDIF}
            ExecuteImmediate(metatgt.Tables[i].Uniques[j].AsAlterToInactiveDDL);
        {$IFDEF BENCH}
          Perfs.meta_unique.Stop;
        {$ENDIF}
        end;
        // DEACTIVATE INDICES
        AddLog('  Indices');
        for j := 0 to metatgt.Tables[i].IndicesCount - 1 do
        begin
          AddLog('    %s', [metatgt.Tables[i].Indices[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_indices.Start;
        {$ENDIF}
            ExecuteImmediate(metatgt.Tables[i].Indices[j].AsAlterToInactiveDDL);
        {$IFDEF BENCH}
          Perfs.meta_indices.Stop;
        {$ENDIF}
        end;
      end;

      AddLog(#13#10 + 'Deactivating Primary Keys');
      for i := 0 to metatgt.TablesCount - 1 do
      begin
        // DEACTIVATE PRIMARY KEYS
        for j := 0 to metatgt.Tables[i].PrimaryCount - 1 do
        begin
          AddLog('  %s (Table %s)', [metatgt.Tables[i].Primary[j].Name, metatgt.Tables[i].Name]);
        {$IFDEF BENCH}
          Perfs.meta_primary.Start;
        {$ENDIF}
            ExecuteImmediate(metatgt.Tables[i].Primary[j].AsDropDDL);
        {$IFDEF BENCH}
          Perfs.meta_primary.Stop;
        {$ENDIF}
        end;
      end;
    end;

    // TABLES DATA
    AddLog(#13#10 + 'Pump Data');
    DstTransaction.Commit;

    ChangeCharset(SrcDatabase, read_charset);
    ChangeCharset(DstDatabase, write_charset);

  {$IFDEF BENCH}
    Perfs.data_pump.Start;
  {$ENDIF}
      dbhandle := DstDatabase.DbHandle;
      FErrorsCount := FErrorsCount + PumpData(dbhandle, metasrc, write_charset, SrcQuery, DstDatabase, DstTransaction);
  {$IFDEF BENCH}
    Perfs.data_pump.Stop;
  {$ENDIF}

    // GENERATORS VALUES
    AddLog(#13#10 + 'Sync Generators');
    for i := 0 to metasrc.GeneratorsCount - 1 do
    begin
      AddLog('  %s', [metasrc.Generators[i].Name]);
    {$IFDEF BENCH}
      Perfs.meta_generators.Start;
    {$ENDIF}
        ExecuteImmediate(metasrc.Generators[i].AsAlterDDL);
    {$IFDEF BENCH}
      Perfs.meta_generators.Stop;
    {$ENDIF}
    end;

    if coPumpOnly in FOptions then
    begin
      AddLog(#13#10 + 'Reactivating Primary Keys');
      for i := 0 to metatgt.TablesCount - 1 do
      begin
        // REACTIVATE PRIMARY KEYS
        for j := 0 to metatgt.Tables[i].PrimaryCount - 1 do
        begin
          AddLog('  %s (Table %s)', [metatgt.Tables[i].Primary[j].Name, metatgt.Tables[i].Name]);
        {$IFDEF BENCH}
          Perfs.meta_primary.Start;
        {$ENDIF}
            ExecuteImmediate(metatgt.Tables[i].Primary[j].AsFullDDL);
        {$IFDEF BENCH}
          Perfs.meta_primary.Stop;
        {$ENDIF}
        end;
      end;

      AddLog(#13#10 + 'Reactivating Other Constraints');
      for i := 0 to metatgt.TablesCount - 1 do
      begin
        AddLog(#13#10 + 'Table %s', [metatgt.Tables[i].Name]);
        // REACTIVATE INDICES
        AddLog('  Indices');
        for j := 0 to metatgt.Tables[i].IndicesCount - 1 do
        begin
          if metatgt.Tables[i].Indices[j].Active then
          begin
            AddLog('    %s', [metatgt.Tables[i].Indices[j].Name]);
          {$IFDEF BENCH}
            Perfs.meta_indices.Start;
          {$ENDIF}
              ExecuteImmediate(metatgt.Tables[i].Indices[j].AsAlterToActiveDDL);
          {$IFDEF BENCH}
            Perfs.meta_indices.Stop;
          {$ENDIF}
          end;
        end;
        // REACTIVATE UNIQUES
        AddLog('  Unique Indices');
        for j := 0 to metatgt.Tables[i].UniquesCount - 1 do
        begin
          AddLog('    %s', [metatgt.Tables[i].Uniques[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_unique.Start;
        {$ENDIF}
            ExecuteImmediate(metatgt.Tables[i].Uniques[j].AsAlterToActiveDDL);
        {$IFDEF BENCH}
          Perfs.meta_unique.Stop;
        {$ENDIF}
        end;
        // REACTIVATE FOREIGN KEYS
        AddLog('  Foreign Keys');
        for j := 0 to metatgt.Tables[i].ForeignCount - 1 do
        begin
          AddLog('    %s', [metatgt.Tables[i].Foreign[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_foreign.Start;
        {$ENDIF}
            ExecuteImmediate(metatgt.Tables[i].Foreign[j].AsFullDDL);
        {$IFDEF BENCH}
          Perfs.meta_foreign.Stop;
        {$ENDIF}
        end;
        // REACTIVATE TRIGGERS
        AddLog('  Triggers');
        for j := 0 to metatgt.Tables[i].TriggersCount - 1 do
        begin
          if metatgt.Tables[i].Triggers[j].Active then
          begin
            AddLog('  %s', [metatgt.Tables[i].Triggers[j].Name]);
          {$IFDEF BENCH}
            Perfs.meta_triggers.Start;
          {$ENDIF}
              ExecuteImmediate(metatgt.Tables[i].Triggers[j].AsAlterToActiveDDL);
          {$IFDEF BENCH}
            Perfs.meta_triggers.Stop;
          {$ENDIF}
          end;
        end;
      end;
    end;

    if not (coPumpOnly in FOptions) then
    begin
      // PRIMARY
      AddLog(#13#10 + 'Create Primary Keys Constraints');
      for i := 0 to metasrc.TablesCount - 1 do
      for j := 0 to metasrc.Tables[i].PrimaryCount - 1 do
      begin
        AddLog('  %s', [metasrc.Tables[i].Primary[j].Name]);
      {$IFDEF BENCH}
        Perfs.meta_primary.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Tables[i].Primary[j].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_primary.Stop;
      {$ENDIF}
      end;

      // FOREIGN
      AddLog(#13#10 + 'Create Foreign Keys Constraints');
      for i := 0 to metasrc.TablesCount - 1 do
      for j := 0 to metasrc.Tables[i].ForeignCount - 1 do
      begin
        AddLog('  %s', [metasrc.Tables[i].Foreign[j].Name]);
      {$IFDEF BENCH}
        Perfs.meta_foreign.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Tables[i].Foreign[j].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_foreign.Stop;
      {$ENDIF}
      end;

      // UNIQUE
      AddLog(#13#10 + 'Create Unique Constraints');
      for i := 0 to metasrc.TablesCount - 1 do
      for j := 0 to metasrc.Tables[i].UniquesCount - 1 do
      begin
        AddLog('  %s', [metasrc.Tables[i].Uniques[j].Name]);
      {$IFDEF BENCH}
        Perfs.meta_unique.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Tables[i].Uniques[j].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_unique.Stop;
      {$ENDIF}
      end;

      // INDICES
      AddLog(#13#10 + 'Create Indices');
      for i := 0 to metasrc.TablesCount - 1 do
      for j := 0 to metasrc.Tables[i].IndicesCount - 1 do
      begin
        AddLog('  %s', [metasrc.Tables[i].Indices[j].Name]);
      {$IFDEF BENCH}
        Perfs.meta_indices.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Tables[i].Indices[j].AsDDL);
          if not metasrc.Tables[i].Indices[j].Active then
            ExecuteImmediate(metasrc.Tables[i].Indices[j].AsAlterToInactiveDDL);
      {$IFDEF BENCH}
        Perfs.meta_indices.Stop;
      {$ENDIF}
      end;

      // CHECKS
      AddLog(#13#10 + 'Create Check Constraints');
      for i := 0 to metasrc.TablesCount - 1 do
      for j := 0 to metasrc.Tables[i].ChecksCount - 1 do
      begin
        AddLog('  %s', [metasrc.Tables[i].Checks[j].Name]);
      {$IFDEF BENCH}
        Perfs.meta_checks.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Tables[i].Checks[j].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_checks.Stop;
      {$ENDIF}
      end;

      // TABLE TRIGGERS
      AddLog(#13#10 + 'Create Triggers');
      for i := 0 to metasrc.TablesCount - 1 do
      for j := 0 to metasrc.Tables[i].TriggersCount - 1 do
      begin
        AddLog('  %s', [metasrc.Tables[i].Triggers[j].Name]);
      {$IFDEF BENCH}
        Perfs.meta_triggers.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Tables[i].Triggers[j].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_triggers.Stop;
      {$ENDIF}
      end;

      // VIEW TRIGGERS
      AddLog(#13#10 + 'Create Views');
      for i := 0 to metasrc.ViewsCount - 1 do
      for j := 0 to metasrc.Views[i].TriggersCount - 1 do
      begin
        AddLog('  %s', [metasrc.Views[i].Triggers[j].Name]);
      {$IFDEF BENCH}
        Perfs.meta_triggers.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Views[i].Triggers[j].AsFullDDL);
      {$IFDEF BENCH}
        Perfs.meta_triggers.Stop;
      {$ENDIF}
      end;

      // ALTER PROCEDURES
      AddLog(#13#10 + 'Create Procedures Code');
      for i := 0 to metasrc.ProceduresCount - 1 do
      begin
        AddLog('  %s', [metasrc.Procedures[i].Name]);
      {$IFDEF BENCH}
        Perfs.meta_procedures.Start;
      {$ENDIF}
          ExecuteImmediate(metasrc.Procedures[i].AsAlterDDL);
      {$IFDEF BENCH}
        Perfs.meta_procedures.Stop;
      {$ENDIF}
      end;

      // GRANTS
      AddLog(#13#10 + 'Grant Roles');
      for i := 0 to metasrc.RolesCount - 1 do
      begin
        for j := 0 to metasrc.Roles[i].GrantsCount - 1 do
        begin
           AddLog('  %s', [metasrc.Roles[i].Grants[j].Name]);
         {$IFDEF BENCH}
           Perfs.meta_grants.Start;
         {$ENDIF}
             ExecuteImmediate(metasrc.Roles[i].Grants[j].AsFullDDL);
         {$IFDEF BENCH}
           Perfs.meta_grants.Stop;
         {$ENDIF}
        end;
      end;

      AddLog(#13#10 + 'Grant Tables and Fields');
      for i := 0 to metasrc.TablesCount - 1 do
      begin
        for j := 0 to metasrc.Tables[i].GrantsCount - 1 do
        begin
          AddLog('  Table %s', [metasrc.Tables[i].Grants[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_grants.Start;
        {$ENDIF}
            ExecuteImmediate(metasrc.Tables[i].Grants[j].AsFullDDL);
        {$IFDEF BENCH}
          Perfs.meta_grants.Stop;
        {$ENDIF}
        end;
        for j := 0 to metasrc.Tables[i].FieldsGrantsCount - 1 do
        begin
          AddLog('  Field %s', [metasrc.Tables[i].FieldsGrants[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_grants.Start;
        {$ENDIF}
            ExecuteImmediate(metasrc.Tables[i].FieldsGrants[j].AsFullDDL);
        {$IFDEF BENCH}
          Perfs.meta_grants.Stop;
        {$ENDIF}
        end;
      end;

      AddLog(#13#10 + 'Grant Views and Fields');
      for i := 0 to metasrc.ViewsCount - 1 do
      begin
        for j := 0 to metasrc.Views[i].GrantsCount - 1 do
        begin
          AddLog('  View %s', [metasrc.Views[i].Grants[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_grants.Start;
        {$ENDIF}
            ExecuteImmediate(metasrc.Views[i].Grants[j].AsFullDDL);
        {$IFDEF BENCH}
          Perfs.meta_grants.Stop;
        {$ENDIF}
        end;
        for j := 0 to metasrc.Views[i].FieldsGrantsCount - 1 do
        begin
          AddLog('  Field %s', [metasrc.Views[i].FieldsGrants[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_grants.Start;
        {$ENDIF}
            ExecuteImmediate(metasrc.Tables[i].FieldsGrants[j].AsFullDDL);
        {$IFDEF BENCH}
          Perfs.meta_grants.Stop;
        {$ENDIF}
        end;
      end;

      AddLog(#13#10 + 'Grant Procedures');
      for i := 0 to metasrc.ProceduresCount - 1 do
      begin
        for j := 0 to metasrc.Procedures[i].GrantsCount - 1 do
        begin
          AddLog('  %s', [metasrc.Procedures[i].Grants[j].Name]);
        {$IFDEF BENCH}
          Perfs.meta_grants.Start;
        {$ENDIF}
            ExecuteImmediate(metasrc.Procedures[i].Grants[j].AsFullDDL);
        {$IFDEF BENCH}
          Perfs.meta_grants.Stop;
        {$ENDIF}
        end;
      end;
    end;
  finally
    metatgt.Free;
    metasrc.Free;
    SrcQuery.Free;
    SrcTransaction.Free;
    SrcDatabase.Free;
    DstTransaction.Free;
    DstDatabase.Free;
    if FErrorsCount > 0 then
    begin
      AddLog('--- %d error(s) ! ---', [FErrorsCount], llError);
      Result := False;
    end;

  {$IFDEF BENCH}
    Perfs.duration.Stop;

    AddLog(#13#10 + 'Overall Counters');
    AddLog(' Duration           %s', [Perfs.duration.duration.ToString]);
    AddLog(' Data Pump          %s', [Perfs.data_pump.duration.ToString]);
    AddLog(' Source Database');
    AddLog('  Connection        %s', [Perfs.source_connection.duration.ToString]);
    AddLog('  Disconnection     %s', [Perfs.source_disconnection.duration.ToString]);
    AddLog('  Metadata Loading  %s', [Perfs.source_metadata.duration.ToString]);
    AddLog(' Target Database');
    AddLog('  Connection        %s', [Perfs.target_connection.duration.ToString]);
    AddLog('  Disconnection     %s', [Perfs.target_disconnection.duration.ToString]);
    AddLog('  Drop              %s', [Perfs.target_drop.duration.ToString]);
    AddLog('  Creation          %s', [Perfs.target_creation.duration.ToString]);
    AddLog('  Metadata Loading  %s', [Perfs.target_metadata.duration.ToString]);
    if not (coPumpOnly in FOptions) then
    begin
      AddLog(' Metadata Cloning');
      AddLog('  Roles             %s', [Perfs.meta_roles.duration.ToString]);
      AddLog('  User Functions    %s', [Perfs.meta_functions.duration.ToString]);
      AddLog('  Domains           %s', [Perfs.meta_domains.duration.ToString]);
      AddLog('  Generators        %s', [Perfs.meta_generators.duration.ToString]);
      AddLog('  Exceptions        %s', [Perfs.meta_exceptions.duration.ToString]);
      AddLog('  Procedures        %s', [Perfs.meta_procedures.duration.ToString]);
      AddLog('  Tables            %s', [Perfs.meta_tables.duration.ToString]);
      AddLog('  Views             %s', [Perfs.meta_views.duration.ToString]);
      AddLog('  Unique Index      %s', [Perfs.meta_unique.duration.ToString]);
      AddLog('  Primary Keys      %s', [Perfs.meta_primary.duration.ToString]);
      AddLog('  Foreign Keys      %s', [Perfs.meta_foreign.duration.ToString]);
      AddLog('  Indices           %s', [Perfs.meta_indices.duration.ToString]);
      AddLog('  Triggers          %s', [Perfs.meta_triggers.duration.ToString]);
      AddLog('  Check Constraints %s', [Perfs.meta_checks.duration.ToString]);
      AddLog('  Grants            %s', [Perfs.meta_grants.duration.ToString]);
    end;
{$ENDIF}
  end;
end;

end.
